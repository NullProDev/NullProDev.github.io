<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <div id="canvascont">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>
        <div id="tools">
            <button id="clear">Clear</button>
            <div id="toolbar">
                <!--pen, eraser and fill tool-->
                <input type="radio" id="pen" name="tool"> Pen <br>
                <input type="radio" id="eraser" name="tool"> Eraser <br>
                <input type="radio" id="fill" name="tool"> Fill <br>
                <input type="radio" id="line" name="tool"> Line <br>
                <input type="radio" id="eyedropper" name=""> Eye Dropper <br>
                <button id="export">Export</button>
            </div>
            <div class="sbs">
                <button id="undo">Undo</button>
                <button id="redo">Redo</button>
            </div>
            <div class="sbs">
                <button id="psminus">-</button>
                <p id="ps"> 1 </p>
                <button id="psplus">+</button>
            </div>
        </div>
    </div>
    <div id="container">
        <div id="color-wheel"></div>
        <input type="color" id="wheel" />
    </div>
</body>
<style>
    #canvascont {
        width: 800px;
        height: 600px;
        overflow: hidden;
    }

    input[type="radio"] {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        border: 1px solid black;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: inline-block;
        position: relative;
        cursor: pointer;
        margin: 5px 10px;
        vertical-align: middle;
    }

    input[type="radio"]:checked::before {
        content: '';
        display: block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: black;
    }

    .sbs {
        display: flex;
        flex-direction: row;
    }

    button {
        border: 0;
        background-color: white;
        padding: 15px 32px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
    }

    #app {
        display: flex;
        flex-direction: row;
    }

    canvas {
        border: 1px solid black;
        background-image: linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc 100%), linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc 100%);
        background-size: 20px 20px;
        background-position: 0 0, 10px 10px;
    }

    #container {
        margin-top: 20px;
        display: flex;
    }

    #wheel {
        height: 50px;
        width: 50px;
        margin-top: 7px;
        border: 0;

    }

    #clear {
        height: 50px;
        width: 100px;
        font-size: 20px;
        border: 0;
        background-color: black;
        color: white;
        padding: 15px 32px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
    }

    #eyedropper {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        border: 1px solid black;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: inline-block;
        position: relative;
        cursor: pointer;
        margin: 5px 10px;
        vertical-align: middle;
    }
</style>
<script>
    var canvas = document.getElementById('canvas');
    var context = canvas.getContext('2d');

    var width = canvas.width;
    var height = canvas.height;

    var gridSize = 5;
    var gridWidth = width / gridSize;
    var gridHeight = height / gridSize;
    var grid = [];
    var zoom = 1;
    //export
    var exportButton = document.getElementById('export');
    exportButton.addEventListener('click', function () {
        //confirm
        var r = confirm('Are you sure you want to export?');
        if (!r) {
            return;
        }
        var dataURL = canvas.toDataURL();
        var a = document.createElement('a');
        a.href = dataURL;
        a.download = 'pixel-art.png';
        a.click();
    });
    function colourNameToHex(colour) {

        var allColors = {
            "black": "#000000", "blue": "#0000ff", "brown": "#a52a2a", "cyan": "#00ffff", "gold": "#ffd700", "gray": "#808080", "green": "#008000", "indigo": "#4b0082", "magenta": "#ff00ff", "orange": "#ffa500", "pink": "#ffc0cb", "purple": "#800080", "red": "#ff0000", "violet": "#ee82ee", "white": "#ffffff", "yellow": "#ffff00"
        };
        if (typeof allColors[colour.toLowerCase()] != 'undefined') {
            return allColors[colour.toLowerCase()];
        }
        return false;
    }
    //+- pen size
    var addPensize = document.getElementById('psplus');
    var subtractMinus = document.getElementById('psminus');
    var pen = document.getElementById('ps');
    var line = document.getElementById('line');
    addPensize.addEventListener('click', function () {
        penSize++;
        updatePenSize();
    });

    subtractMinus.addEventListener('click', function () {
        if (penSize > 0) {
            penSize--;
        }
        updatePenSize();
    });
    //undo and redo with ctrl z and ctrl shift z
    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'black', 'white'];
    let penSize = 0;
    function updatePenSize() {
        document.getElementById('ps').innerHTML = penSize + 1;
    }
    var eyedropper = document.getElementById('eyedropper');
    document.addEventListener('keydown', function (e) {
        if (e.ctrlKey && e.key === 'z') {
            undo.click();
        }
        if (e.ctrlKey && e.shiftKey && e.key === 'Z') {
            redo.click();
        }
        if (e.key === 'c') {
            clear.click();
        }
        if (e.key === 'p') {
            pen.click();
        }
        if (e.key === 'e') {
            eraser.click();
        }
        if (e.key === 'f') {
            fill.click();
        }
        if (e.key === 'l') {
            line.click();
        }
        if (e.key === '=' || e.key === '+') {
            penSize += 1;
            updatePenSize();
        }
        if (e.key === 'i') {
            eyedropper.click();
        }
        if (e.key === '-') {
            if (penSize > 0) {
                penSize -= 1;
                updatePenSize();
            }
        }
        // if key is a number
        if (e.key >= 0 && e.key <= 9) {
            color = colors[parseInt(e.key)];
            wheel.value = colourNameToHex(color);
        }
    });

    //color wheel
    var colorWheel = document.getElementById('color-wheel');
    var wheel = document.getElementById('wheel');
    for (var i = 0; i < colors.length; i++) {
        var div = document.createElement('div');
        div.style.width = '50px';
        div.style.height = '50px';
        div.style.backgroundColor = colors[i];
        div.style.display = 'inline-block';
        div.style.margin = '10px';
        div.onclick = function () {
            color = this.style.backgroundColor;
            wheel.value = colourNameToHex(color);
        };
        colorWheel.appendChild(div);
    }
    var color = 'black';
    //get input from wheel
    wheel.addEventListener('input', function () {
        color = wheel.value;
    });

    //split canvas into a grid and only allow drawing in the grid
    //mobile convert touch to mouse events
    canvas.addEventListener('touchstart', function (e) {
        startPoint = { x: e.offsetX, y: e.offsetY };
        if (line.checked) {
            startingGrid = grid.map(row => [...row]);
        }
        mouseDown = true;
        if (!line.checked) {
            draw(e);
        }
    });
    canvas.addEventListener('touchmove', function (e) {
        e.preventDefault();
        if (!line.checked) {
            draw(e);
        }
        if (line.checked && startPoint) {
            endPoint = { x: e.offsetX, y: e.offsetY };
            //draw the grid to be starting grid
            grid = startingGrid.map(row => [...row]);
            //redraw only changed pixels
            redrawGrid();
            if (mouseDown) {
                drawLine(startPoint.x, startPoint.y, endPoint.x, endPoint.y, penSize);
                pushToHistory(grid.map(row => [...row]));
            }

        }
    });
    canvas.addEventListener('touchend', function (e) {
        if (line.checked && startPoint) {
            endPoint = { x: e.offsetX, y: e.offsetY };
            //drawLine(startPoint.x, startPoint.y, endPoint.x, endPoint.y, penSize);
            //console.log(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
            //save to undo
            pushToHistory(grid.map(row => [...row]));
        }
        startPoint = null;
        mouseDown = false;
    });
    //convert two finger zoom to scroll 



    //zoom in and out of the canvas with the mouse wheel
    canvas.addEventListener('wheel', function (e) {
        e.preventDefault();
        if (e.deltaY < 0) {
            zoom *= 1.1;
        } else {
            zoom /= 1.1;
        }
        if (zoom < .2) {
            zoom = .2;
        }
        //get pixel mouse is over
        //translate the canvas so that the mouse is always over the same pixel
        canvas.style.transformOrigin = '50% 50%';
        canvas.style.transform = 'scale(' + zoom + ')';

    });
    //pixel art
    for (var i = 0; i < gridWidth; i++) {
        grid[i] = [];
        for (var j = 0; j < gridHeight; j++) {
            // erase all
            grid[i][j] = '';


        }
    }
    //draw on grid
    var mouseDown = false;
    var isDrawing = false;
    canvas.addEventListener('mousedown', function (e) {
        pushToHistory(grid.map(row => [...row]));
        startPoint = { x: e.offsetX, y: e.offsetY };
        if (line.checked) {
            startingGrid = grid.map(row => [...row]);
        }
        mouseDown = true;
        if (!line.checked) {
            draw(e);
        }
    });
    canvas.addEventListener('mouseup', function (e) {
        if (line.checked && startPoint) {
            endPoint = { x: e.offsetX, y: e.offsetY };
            pushToHistory(grid.map(row => [...row]));
        }
        startPoint = null;
        mouseDown = false;
    });
    //mouse move event
    canvas.addEventListener('mousemove', function (e) {
        if (!line.checked) {
            draw(e);
        }
        if (line.checked && startPoint) {
            endPoint = { x: e.offsetX, y: e.offsetY };
            //draw the grid to be starting grid
            grid = startingGrid.map(row => [...row]);
            //redraw only changed pixels
            redrawGrid();
            if (mouseDown) {
                var start = performance.now();
                drawLine(startPoint.x, startPoint.y, endPoint.x, endPoint.y, penSize);
                console.log(performance.now() - start + 'ms');

            }

        }

    });

    //undo and redo
    var undo = document.getElementById('undo');
    var redo = document.getElementById('redo');
    //check if two grids are the same
    function isSameGrid(grid1, grid2) {
        for (var i = 0; i < gridWidth; i++) {
            for (var j = 0; j < gridHeight; j++) {
                if (grid1[i][j] !== grid2[i][j]) {
                    return false;
                }
            }
        }
        return true;
    }
    undo.addEventListener('click', function () {
        if (undoHistory.length > 0) {
            redoHistory.push(grid.map(row => [...row]));
            grid = undoHistory.pop();
            redrawGrid();
        }
    });
    redo.addEventListener('click', function () {
        if (redoHistory.length > 0) {
            undoHistory.push(grid.map(row => [...row]));
            grid = redoHistory.pop();
            redrawGrid();
        }
    });
    var undoHistory = [];
    var redoHistory = [];
    function pushToHistory(grid) {
        if (undoHistory.length === 0) {
            undoHistory.push(grid);
            return;
        }
        if (!isSameGrid(grid, undoHistory[undoHistory.length - 1])) {
            undoHistory.push(grid);
            redoHistory = [];
        }
    }
    function redrawGrid() {
        for (var i = 0; i < gridWidth; i++) {
            for (var j = 0; j < gridHeight; j++) {

                if (grid[i][j] === '') {
                    context.clearRect(i * gridSize, j * gridSize, gridSize, gridSize);
                } else {
                    context.fillStyle = grid[i][j];
                    context.fillRect(i * gridSize, j * gridSize, gridSize, gridSize);
                }
            }
        }
        context.strokeStyle = 'black';
    }
    //check if pen or eraser is selected
    function draw(e) {
        endPoint = { x: e.offsetX, y: e.offsetY };

        grid = grid.map(row => row.map(cell => cell.trim()));
        //add to history
        if (!mouseDown) {

            return;
        }
        if (pen.checked) {
            pushToHistory(grid.map(row => [...row]));
            drawPixel(e, penSize);
        } else if (eraser.checked) {
            pushToHistory(grid.map(row => [...row]));
            erasePixel(e, penSize);
        } else if (fill.checked) {
            pushToHistory(grid.map(row => [...row]));
            fillPixel(e);
        } else if (eyedropper.checked) {
            eyedropperTool(e);
        }
    }
    function eyedropperTool(e) {
        var rect = canvas.getBoundingClientRect();
        var x = (e.pageX - window.scrollX - rect.left) / zoom;
        var y = (e.pageY - window.scrollY - rect.top) / zoom;
        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);
        color = grid[i][j];
        if (color.includes("#")) {
            wheel.value = color;
        } else {
            wheel.value = colourNameToHex(color);
        }
    }
    var startPoint = null;
    var endPoint = null;
    var queue2 = [];
    function drawLine(x, y, x2, y2, rad) {
        rad2 = rad * 4;
        var s = (y2 - y) / (x2 - x);
        var radX, radY;
        if (s === 0) {
            // The line is horizontal
            radX = 0;
            radY = rad2;
        } else {
            var angle = Math.atan2(y2 - y, x2 - x); // angle of the line
            radX = rad2 * Math.sin(angle); // offset in x direction
            radY = rad2 * Math.cos(angle); // offset in y direction
        }
        //draw a line between the edges of the circle
        drawLinePos(x - radX, y + radY, x2 - radX, y2 + radY, 0);
        drawLinePos(x + radX, y - radY, x2 + radX, y2 - radY, 0);
        drawLinePos(x - radX, y + radY, x + radX, y - radY, 0);
        drawLinePos(x2 - radX, y2 + radY, x2 + radX, y2 - radY, 0);
        if (rad > 1) {
            drawLine(x, y, x2, y2, rad - 1);
        }
        drawLinePos(x, y, x2, y2, 0);

    }

    function drawLinePos(x, y, x2, y2) {
        //use bresenhams line algorithm to draw a line between x,y and x2,y2
        var slope = (y2 - y) / (x2 - x);
        var dx = Math.abs(x2 - x);
        var dy = Math.abs(y2 - y);
        var steps = Math.max(dx, dy);
        var xInc = (x2 - x) / steps;
        var yInc = (y2 - y) / steps;
        for (var i = 0; i <= steps; i++) {
            drawPixelCoords(x + i * xInc, y + i * yInc, 0);
        }

    }
    function drawPixelCoords(x, y, penSize) {
        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);
        // Draw a circle of pixels around the point (i, j)
        for (var di = -penSize; di <= penSize; di++) {
            for (var dj = -penSize; dj <= penSize; dj++) {
                // Calculate the distance to the center point
                var dist = Math.sqrt(di * di + dj * dj);
                // If the distance is less than or equal to the penSize, color the point
                if (dist <= penSize) {
                    var ii = i + di;
                    var jj = j + dj;
                    // Check if the point is inside the grid
                    if (ii >= 0 && ii < grid.length && jj >= 0 && jj < grid[0].length) {
                        grid[ii][jj] = color;
                        context.fillStyle = color;
                        context.fillRect(ii * gridSize, jj * gridSize, gridSize, gridSize);
                    }
                }
            }
        }
    }
    function drawPixel(e, penSize) {
        var rect = canvas.getBoundingClientRect();
        var x = e.pageX - window.scrollX - rect.left;
        var y = e.pageY - window.scrollY - rect.top;
        var x = (e.pageX - window.scrollX - rect.left) / zoom;
        var y = (e.pageY - window.scrollY - rect.top) / zoom;

        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);
        // Draw a circle of pixels around the point (i, j)
        for (var di = -penSize; di <= penSize; di++) {
            for (var dj = -penSize; dj <= penSize; dj++) {
                // Calculate the distance to the center point
                var dist = Math.sqrt(di * di + dj * dj);
                // If the distance is less than or equal to the penSize, color the point
                if (dist <= penSize) {
                    var ii = i + di;
                    var jj = j + dj;
                    // Check if the point is inside the grid
                    if (ii >= 0 && ii < grid.length && jj >= 0 && jj < grid[0].length) {
                        grid[ii][jj] = color;
                        context.fillStyle = color;
                        context.fillRect(ii * gridSize, jj * gridSize, gridSize, gridSize);
                    }
                }
            }
        }
    }
    //erase pixel
    function erasePixel(e, penSize) {
        var rect = canvas.getBoundingClientRect();
        var x = (e.pageX - window.scrollX - rect.left) / zoom;
        var y = (e.pageY - window.scrollY - rect.top) / zoom;

        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);

        // Draw a circle of pixels around the point (i, j)
        for (var di = -penSize; di <= penSize; di++) {
            for (var dj = -penSize; dj <= penSize; dj++) {
                // Calculate the distance to the center point
                var dist = Math.sqrt(di * di + dj * dj);
                // If the distance is less than or equal to the penSize, color the point
                if (dist <= penSize) {
                    var ii = i + di;
                    var jj = j + dj;
                    // Check if the point is inside the grid
                    if (ii >= 0 && ii < grid.length && jj >= 0 && jj < grid[0].length) {
                        var rect = canvas.getBoundingClientRect();
                        grid[ii][jj] = '';
                        context.clearRect(ii * gridSize, jj * gridSize, gridSize, gridSize);


                    }
                }
            }
        }
    }
    //flood fill
    function includesCoordinate(checked, coord) {
        for (var i = 0; i < checked.length; i++) {
            if (checked[i][0] === coord[0] && checked[i][1] === coord[1]) {
                return true;
            }
        }
        return false;
    }

    function fillPixel(e) {
        var rect = canvas.getBoundingClientRect();
        var x = (e.pageX - window.scrollX - rect.left) / zoom;
        var y = (e.pageY - window.scrollY - rect.top) / zoom;
        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);
        var targetColor = grid[i][j];
        //log the time the function takes to execute in ms
        var start = performance.now();
        //oldfloodFill(i, j, targetColor, color);
        floodFill(i, j, targetColor, color);
        console.log(performance.now() - start + 'ms');
        redrawGrid();
    }

    //flood fill algorithm
    function floodFill(x, y, targetColor, replacementColor) {
        //create empty stack
        var queue = [[x, y]];
        var visited = new Set();
        //add to stack
        //while stack is not empty
        while (queue.length) {
            //remove first value from stack
            var [i, j] = queue.shift();
            //if the pixel is out of bounds, continue
            if (i < 0 || i >= gridWidth || j < 0 || j >= gridHeight) {
                continue;
            }
            if (grid[i][j] !== targetColor) {
                continue;
            }
            var coord = `${i},${j}`;
            if (visited.has(coord)) {
                continue;
            }
            grid[i][j] = replacementColor;
            redrawPixel(i, j);
            visited.add(coord);
            queue.push([i + 1, j]);
            queue.push([i - 1, j]);
            queue.push([i, j + 1]);
            queue.push([i, j - 1]);
        }
    }

    function redrawPixel(i, j) {
        context.fillStyle = grid[i][j];
        context.fillRect(i * gridSize, j * gridSize, gridSize, gridSize);
    }

    //clear button, remove all pixels, and redraw the grid
    var clear = document.getElementById('clear');
    clear.addEventListener('click', function () {
        context.clearRect(0, 0, width, height);
        for (var i = 0; i < gridWidth; i++) {
            for (var j = 0; j < gridHeight; j++) {
                grid[i][j] = '';
            }
        }

    });

    //make sure that all other tools aren't selected 
    var pen = document.getElementById('pen');
    pen.checked = true;
    pen.addEventListener('click', function () {
        pen.checked = true;
        eraser.checked = false;
        fill.checked = false;
        eyedropper.checked = false;
    });

    var eraser = document.getElementById('eraser');
    eraser.addEventListener('click', function () {
        pen.checked = false;
        eraser.checked = true;
        fill.checked = false;
        line.checked = false;
        eyedropper.checked = false;
    });

    var fill = document.getElementById('fill');
    fill.addEventListener('click', function () {
        pen.checked = false;
        eraser.checked = false;
        fill.checked = true;
        line.checked = false;
        eyedropper.checked = false;
    });

    line.addEventListener('click', function () {
        pen.checked = false;
        eraser.checked = false;
        fill.checked = false;
        line.checked = true;
        eyedropper.checked = false;
    });

    eyedropper.addEventListener('click', function () {
        pen.checked = false;
        eraser.checked = false;
        fill.checked = false;
        line.checked = false;
        eyedropper.checked = true;
    });
</script>

</html>