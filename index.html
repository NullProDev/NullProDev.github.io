<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="manifest" href="manifest.json" />
    <title>APixel</title>
</head>

<body>
    <div id="app">
        <div id="canvascont">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>
        <div id="tools">
            <button id="clear">Clear</button>
            <button id="export">Export</button>
            <button id="undo">Undo</button>
            <button id="redo">Redo</button>
            <div id="toolbar">
                <!--pen, eraser and fill tool-->
                <div><input type="radio" id="pen" name="tool"> Pen</div>

                <div><input type="radio" id="eraser" name="tool"> Eraser</div>
                <div><input type="radio" id="fill" name="tool"> Fill</div>
                <div><input type="radio" id="line" name="tool"> Line</div>
                <div><input type="radio" id="circle" name="tool"> Circle</div>
                <div><input type="radio" id="rect" name="tool"> Rectangle</div>
                <div><input type="radio" id="eyedropper" name="tool"> Eyedropper</div>
                <input type="radio" id="select" name="tool">
            </div>
            <div class="sbs" style="margin-top: auto; margin-bottom: auto;"><input type="range" id="zoom" value="1"
                    max="5" mix="1" step=".1" name=""></div>
            <div class="sbs">
                <button id="psminus">-</button>
                <input id="ps" value="1" />
                <button id="psplus">+</button>
                <input id="grid" style="margin-top: auto; margin-bottom: auto; margin-left: 50px;" type="number"
                    value="2" min="1" />
            </div><br>
        </div>
    </div>
    <div id="container">
        <div id="color-wheel"></div>
        <div id="border">
            <input type="color" id="wheel" />
            <button id="addpalette" class="">Add to Palette</button>
            <button id="importP">Import Palette</button>
            <button id="exportP">Export Palette</button>
        </div>
    </div>
</body>
<style>
    #select {
        display: none;
    }

    #border {
        border: 1px solid black;
        padding: 10px;
        margin-top: 0px;
        margin-bottom: 0;
        padding: 0 1em 0 1em;
        /* align the buttons at the top */
        display: flex;
        flex-direction: row;
        justify-content: center;
        align-items: center;

    }

    #canvascont {

        /* make responsive */
        height: 40%;
        aspect-ratio: 4 / 3;
        overflow: hidden;
        border: 1px solid black;
    }

    input[type="radio"] {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        border: 1px solid black;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: inline-block;
        position: relative;
        cursor: pointer;
        margin: 5px 10px;
        vertical-align: middle;
    }

    input[type="radio"]:checked::before {
        content: '';
        display: block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: black;
    }

    .sbs {
        display: flex;
        flex-direction: row;
        vertical-align: middle;
        align-items: center;

    }

    #ps,
    #grid {
        height: 30px;
        text-align: center;
        width: 30px;
        vertical-align: middle;
    }

    button {
        border: 0;
        background-color: inherit;
        padding: 15px 25px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;

    }

    #toolbar>div {
        display: flex;
        align-items: center;
    }

    #tools {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }

    @media only screen and (min-width: 600px) {
        #app {
            display: flex;
            flex-direction: row;
        }

        #toolbar {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
    }

    @media only screen and (min-width: 1000px) {

        /* make container side by side */
        #container {
            display: flex;
            flex-direction: row;
            align-items: flex-start;

        }
    }

    @media only screen and (max-width: 600px) {
        #canvascont {
            width: 100%;
        }

        #toolbar {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        #tools {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        #toolbar>div {
            flex-direction: row;
        }

        #zoom {
            display: none;
        }
    }


    canvas {
        border: 1px solid black;
        background-image: linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc 100%), linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc 100%);
        background-size: 20px 20px;
        background-position: 0 0, 10px 10px;
        transform-origin: 50% 50%;
    }


    #wheel {
        height: 50px;
        width: 50px;
        margin-top: 7px;
        border: 0;
        aspect-ratio: 1 / 1;
    }

    #clear {
        height: 50px;
        width: 100px;
        font-size: 20px;
        border: 0;
        background-color: black;
        color: white;
        padding: 15px 32px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
    }

    #eyedropper {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        border: 1px solid black;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: inline-block;
        position: relative;
        cursor: pointer;
        margin: 5px 10px;
        vertical-align: middle;
    }
</style>
<script>
    var canvas = document.getElementById('canvas');
    var context = canvas.getContext('2d');
    var canvascont = document.getElementById('canvascont');
    var width = canvas.width;
    var height = canvas.height;
    var gridSize = 5;
    var gridWidth = width / gridSize;
    var gridHeight = height / gridSize;
    var grid = [];
    var zoom = 1;
    var gridInput = document.getElementById('grid');
    var w = canvascont.offsetWidth;
    var h = canvascont.offsetHeight;
    console.log(w, h);
    canvas.style.transformOrigin = w / 2 + 'px ' + h / 2 + 'px';
    window.addEventListener('resize', function () {
        var w = canvascont.offsetWidth;
        var h = canvascont.offsetHeight;
        console.log(w, h);
        canvas.style.transformOrigin = w / 2 + 'px ' + h / 2 + 'px';
        //canvas.translate = 'translate(' + w / 2 + 'px,' + h / 2 + 'px)';
    });
    //on resize window, move the canvas to the center
    gridInput.value = gridSize;
    gridInput.addEventListener('input', function () {
        gridSize = parseInt(gridInput.value);
        gridWidth = width / gridSize;
        gridHeight = height / gridSize;
        grid = [];
        for (var i = 0; i < gridWidth; i++) {
            grid[i] = [];
            for (var j = 0; j < gridHeight; j++) {
                grid[i][j] = '';
            }
        }
        points = [];
        redrawGrid();
    });
    var zoomInput = document.getElementById('zoom');
    zoomInput.addEventListener('input', function () {
        if (zoomInput.value < .2) {
            zoomInput.value = .2;
        } else if (zoomInput.value > 5) {
            zoomInput.value = 5;
        }
        zoom = zoomInput.value;
        canvas.style.transform = 'scale(' + zoom + ')';
    });
    //export
    var exportButton = document.getElementById('export');
    exportButton.addEventListener('click', function () {
        //confirm
        var r = confirm('Are you sure you want to export?');
        if (!r) {
            return;
        }
        var dataURL = canvas.toDataURL();
        //divide width and height by gridSize
        var canvas2 = document.createElement('canvas');
        var context2 = canvas2.getContext('2d');
        canvas2.width = gridWidth;
        canvas2.height = gridHeight;
        for (var i = 0; i < gridWidth; i++) {
            for (var j = 0; j < gridHeight; j++) {
                if (grid[i][j] !== '') {
                    context2.fillStyle = grid[i][j];
                    context2.fillRect(i, j, 1, 1);
                }
            }
        }
        var a = document.createElement('a');
        a.href = canvas2.toDataURL();
        a.download = 'pixel-art.png';
        a.click();
    });

    document.addEventListener('resize', function () {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

    });

    function colourNameToHex(colour) {
        //if rgb
        if (colour.includes('rgb')) {
            var rgb = colour.match(/\d+/g);
            return "#" + ((1 << 24) + (parseInt(rgb[0]) << 16) + (parseInt(rgb[1]) << 8) + parseInt(rgb[2])).toString(16).slice(1);
        }
        var allColors = {
            "black": "#000000", "blue": "#0000ff", "brown": "#a52a2a", "cyan": "#00ffff", "gold": "#ffd700", "gray": "#808080", "green": "#008000", "indigo": "#4b0082", "magenta": "#ff00ff", "orange": "#ffa500", "pink": "#ffc0cb", "purple": "#800080", "red": "#ff0000", "violet": "#ee82ee", "white": "#ffffff", "yellow": "#ffff00"
        };
        if (typeof allColors[colour.toLowerCase()] != 'undefined') {
            return allColors[colour.toLowerCase()];
        }
        return false;
    }
    //+- pen size
    document.addEventListener('load', function () {
        penSize = 0;
        pen.checked = true;
        eraser.checked = false;
        rect.checked = false;
        circle.checked = false;
        line.checked = false;
        fill.checked = false;
        eyedropper.checked = false;

    });

    var addPensize = document.getElementById('psplus');
    var subtractMinus = document.getElementById('psminus');
    var penSi = document.getElementById('ps');
    penSi.addEventListener('load', function () {
        penSi.value = 1;
        penSize = 0;
    });
    penSi.addEventListener('input', function () {
        penSize = parseInt(penSi.value) - 1;
    });
    addPensize.addEventListener('click', function () {
        penSize++;
        updatePenSize();
    });
    subtractMinus.addEventListener('click', function () {
        if (penSize > 0) {
            penSize--;
        }
        updatePenSize();
    });

    //undo and redo with ctrl z and ctrl shift z
    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'black', 'white'];
    var addPalette = document.getElementById('addpalette');
    addPalette.addEventListener('click', function () {
        colors.push(wheel.value);
        var div = document.createElement('div');
        div.style.width = '50px';
        div.style.height = '50px';
        div.style.backgroundColor = wheel.value;
        div.style.display = 'inline-block';
        div.style.margin = '10px';
        div.style.border = '1px solid black';
        div.onclick = function () {
            color = this.style.backgroundColor;
            wheel.value = colourNameToHex(color);
        };
        colorWheel.appendChild(div);
        if (colors.length > 9) {
            colors.shift();
            colorWheel.removeChild(colorWheel.firstChild);
        }
    });
    var importPalette = document.getElementById('importP');
    importPalette.addEventListener('click', function () {
        var palette = prompt('Enter a palette');
        if (palette) {
            colors = palette.split(',');
            colorWheel.innerHTML = '';
            for (var i = 0; i < colors.length; i++) {
                var div = document.createElement('div');
                div.style.width = '50px';
                div.style.height = '50px';
                div.style.backgroundColor = colors[i];
                div.style.display = 'inline-block';
                div.style.margin = '10px';
                div.style.border = '1px solid black';
                div.onclick = function () {
                    color = this.style.backgroundColor;
                    wheel.value = colourNameToHex(color);
                };
                colorWheel.appendChild(div);
            }
        }
    });
    var exportPalette = document.getElementById('exportP');
    exportPalette.addEventListener('click', function () {
        var palette = colors.join(',');
        var a = document.createElement('a');
        a.href = 'data:text/plain;charset=utf-8,' + encodeURIComponent(palette);
        a.download = 'palette.txt';
        a.click();
    });
    let penSize = 0;
    function updatePenSize() {
        penSi.value = penSize + 1;
    }
    var eyedropper = document.getElementById('eyedropper');
    document.addEventListener('keydown', function (e) {
        if (e.key === 'c') {
            clear.click();
        }
        if (e.key === 'p') {
            pen.click();
        }
        if (e.key === 'e') {
            eraser.click();
        }
        if (e.key === 'f') {
            fill.click();
        }
        if (e.key === 'l') {
            line.click();
        }
        if (e.key === 'r') {
            rect.click();
        }
        if (e.key === 's') {
            circle.click();
        }
        if (e.key === 'i') {
            eyedropper.click();
        }
        if (e.key === '=' || e.key === '+') {
            penSize += 1;
            updatePenSize();
        }
        if (e.key === '-') {
            if (penSize > 0) {
                penSize -= 1;
                updatePenSize();
            }
        }
        if (e.ctrlKey && e.key === 'z') {
            undo.click();
        }
        if (e.ctrlKey && e.shiftKey && e.key === 'Z') {
            redo.click();
        }
        if (e.key === "," || e.key === "<") {
            if (parseInt(gridInput.value) < 1) {
                return;
            }
            gridInput.value = parseInt(gridInput.value) - 1;
            gridSize = parseInt(gridInput.value);
            gridWidth = width / gridSize;
            gridHeight = height / gridSize;
            grid = [];
            for (var i = 0; i < gridWidth; i++) {
                grid[i] = [];
                for (var j = 0; j < gridHeight; j++) {
                    grid[i][j] = '';
                }
            }
            points = [];
            redrawGrid();
        }
        if (e.key === "." || e.key === ">") {
            gridInput.value = parseInt(gridInput.value) + 1;
            gridSize = parseInt(gridInput.value);
            gridWidth = width / gridSize;
            gridHeight = height / gridSize;
            grid = [];
            for (var i = 0; i < gridWidth; i++) {
                grid[i] = [];
                for (var j = 0; j < gridHeight; j++) {
                    grid[i][j] = '';
                }
            }
            redrawGrid();
        }
        // if key is a number
        if (e.key >= 0 && e.key <= 9 && document.activeElement !== penSi && document.activeElement !== gridInput) {
            color = colors[parseInt(e.key)];
            wheel.value = colourNameToHex(color);
        }
    });

    //color wheel
    var colorWheel = document.getElementById('color-wheel');
    var wheel = document.getElementById('wheel');
    for (var i = 0; i < colors.length; i++) {
        var div = document.createElement('div');
        div.style.width = '50px';
        div.style.height = '50px';
        div.style.backgroundColor = colors[i];
        div.style.display = 'inline-block';
        div.style.margin = '10px';
        div.style.border = '1px solid black';
        div.onclick = function () {
            color = this.style.backgroundColor;
            wheel.value = colourNameToHex(color);
        };
        colorWheel.appendChild(div);
    }
    var color = 'black';
    //get input from wheel
    wheel.addEventListener('input', function () {
        color = wheel.value;
    });

    //split canvas into a grid and only allow drawing in the grid
    //mobile convert touch to mouse events
    canvas.addEventListener('touchstart', function (e) {
        e.preventDefault();
        var touch = e.touches[0];
        var mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
    });
    canvas.addEventListener('touchend', function (e) {
        e.preventDefault();
        var mouseEvent = new MouseEvent('mouseup', {});
        canvas.dispatchEvent(mouseEvent);
    });
    var lastDistance = 0;
    canvas.addEventListener('touchmove', function (e) {
        e.preventDefault();
        var touch = e.touches[0];
        if (e.touches.length === 2){
            var delta = Math.abs(e.touches[0].clientX - e.touches[1].clientX) + Math.abs(e.touches[0].clientY - e.touches[1].clientY);
            if (lastDistance === 0){
                lastDistance = delta;
            }
            //create a scroll event
            var event = new WheelEvent('wheel', {
                deltaY: lastDistance - delta
            });
            zoomInOut(event);

        }
        var mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
    });

    //zoom in and out of the canvas with the mouse wheel
    canvas.addEventListener('wheel', function (e) {
        e.preventDefault();
        if (e.deltaY < 0) {
            zoom *= 1.1;
        } else {
            zoom /= 1.1;
        }
        if (zoom < .2) {
            zoom = .2;
        }
        zoomInOut(e);

    });
    function zoomInOut(e) {
        var rect = canvas.getBoundingClientRect();
        var centerX = canvas.width / 2;
        var centerY = canvas.height / 2;
        // Set transform origin to center of canvas
        // Change zoom level
        if (e.deltaY < 0) {
            if (zoom < 5) {
                zoom *= 1.1;
            } else {
                zoom = 5;
                return;
            }
        } else {
            zoom /= 1.1;
        }
        if (zoom < .2) {
            zoom = .2;
        }
        //make sure offset is correct
        var offsetX = (centerX - rect.left) / zoom - centerX;
        var offsetY = (centerY - rect.top) / zoom - centerY;
        canvas.style.transform = 'scale(' + zoom + ')';

    }
    //pixel art
    for (var i = 0; i < gridWidth; i++) {
        grid[i] = [];
        for (var j = 0; j < gridHeight; j++) {
            // erase all
            grid[i][j] = '';
        }
    }

    var selectTool = document.getElementById('select');

    //draw on grid
    var mouseDown = false;
    var isDrawing = false;
    canvas.addEventListener('mousedown', function (e) {
        pushToHistory(grid.map(row => [...row]));
        startPoint = { x: e.offsetX, y: e.offsetY };
        if (line.checked || circle.checked || rect.checked) {
            startingGrid = grid.map(row => [...row]);
        }
        mouseDown = true;
        if (!line.checked) {
            draw(e);
        }
        moving = isInsideSelection(e);
        resizing = isRisingSelection(e);
    });
    canvas.addEventListener('mouseup', function (e) {
        if (line.checked && startPoint) {
            endPoint = { x: e.offsetX, y: e.offsetY };
            pushToHistory(grid.map(row => [...row]));
        }
        startPoint = null;
        mouseDown = false;
        lastPoint = null;
        resizing = false;
        moving = false;
    });
    document.addEventListener('mouseup', function (e) {
        mouseDown = false;
        lastPoint = null;
        startPoint = null;
        resizing = false;
        moving = false;
        initialMouseX = undefined;
        initialMouseY = undefined;
    });
    var resizing = false;
    var selectedCorner = null;
    var moving = false;
    //mouse move event
    canvas.addEventListener('mousemove', function (e) {
        if (eyedropper.checked) {
            canvas.style.cursor = 'crosshair';
        } else {
            canvas.style.cursor = 'default';
        }
        //random color
        if (selectTool.checked) {
            mousePointer(e);
            selectT(e);
            console.log("m", moving, "r", resizing)
        }
        if (mouseDown) {
            if (resizing) {
                resizeSelection(e);
            } else if (moving) {
                moveSelection(e);
            }
        }
        draw(e);
    });
    //undo and redo
    var undo = document.getElementById('undo');
    var redo = document.getElementById('redo');
    //check if two grids are the same
    function isSameGrid(grid1, grid2) {
        for (var i = 0; i < gridWidth; i++) {
            for (var j = 0; j < gridHeight; j++) {
                if (grid1[i][j] !== grid2[i][j]) {
                    return false;
                }
            }
        }
        return true;
    }
    undo.addEventListener('click', function () {
        if (undoHistory.length > 0) {
            redoHistory.push(grid.map(row => [...row]));
            grid = undoHistory.pop();
            redrawGrid();
        }
    });
    redo.addEventListener('click', function () {
        if (redoHistory.length > 0) {
            undoHistory.push(grid.map(row => [...row]));
            grid = redoHistory.pop();
            redrawGrid();
        }
    });
    var undoHistory = [];
    var redoHistory = [];
    function pushToHistory(grid) {
        if (undoHistory.length === 0) {
            undoHistory.push(grid);
            return;
        }
        if (!isSameGrid(grid, undoHistory[undoHistory.length - 1])) {
            undoHistory.push(grid);
            redoHistory = [];
        }
    }
    function redrawGrid() {
        for (var i = 0; i < gridWidth; i++) {
            for (var j = 0; j < gridHeight; j++) {

                if (grid[i][j] === '') {
                    context.clearRect(i * gridSize, j * gridSize, gridSize, gridSize);
                } else {
                    context.fillStyle = grid[i][j];
                    context.fillRect(i * gridSize, j * gridSize, gridSize, gridSize);
                }
            }
        }
        context.strokeStyle = 'black';
    }
    //check if pen or eraser is selected
    var pen = document.getElementById('pen');
    pen.checked = true;
    var eraser = document.getElementById('eraser');
    var fill = document.getElementById('fill');
    var line = document.getElementById('line');
    var circle = document.getElementById('circle');
    var rect = document.getElementById('rect');
    var lastPoint = null;
    var selection = [];
    function draw(e) {
        grid = grid.map(row => row.map(cell => cell.trim()));
        //add to history
        if (!mouseDown) {
            return;
        }
        if (pen.checked) {
            //pushToHistory(grid.map(row => [...row]));
            //draw a line between the last point and the current point
            if (lastPoint) {
                drawLine(lastPoint.x, lastPoint.y, e.offsetX, e.offsetY, Math.round(penSize / 4 * gridSize));
            }
            drawPixel(e, penSize);
        } else if (eraser.checked) {
            pushToHistory(grid.map(row => [...row]));
            erasePixel(e, penSize);
        } else if (fill.checked) {
            pushToHistory(grid.map(row => [...row]));
            fillPixel(e);
        } else if (eyedropper.checked) {
            canvas.style.cursor = 'crosshair';
            eyedropperTool(e);
        } else if (line.checked && startPoint) {
            endPoint = { x: e.offsetX, y: e.offsetY };
            //draw the grid to be starting grid
            grid = startingGrid.map(row => [...row]);
            //redraw only changed pixels
            redrawGrid();
            if (mouseDown) {
                var start = performance.now();
                drawLine(startPoint.x, startPoint.y, endPoint.x, endPoint.y, penSize);
                console.log(performance.now() - start + 'ms');

            }

        } else if (circle.checked && startPoint) {
            endPoint = { x: e.offsetX, y: e.offsetY };
            grid = startingGrid.map(row => [...row]);
            redrawGrid();
            if (mouseDown) {
                drawCircle(startPoint.x, startPoint.y, endPoint.x, endPoint.y, penSize);
            }
        } else if (rect.checked && startPoint) {
            endPoint = { x: e.offsetX, y: e.offsetY };
            grid = startingGrid.map(row => [...row]);
            redrawGrid();
            if (mouseDown) {
                drawRect(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
            }
        }
    }
    function isInsideSelection(e) {
        if (points.length !== 4) {
            return false;
        }
        var rect = canvas.getBoundingClientRect();
        var mouseX = (e.clientX - rect.left) / zoom - canvas.offsetLeft;
        var mouseY = (e.clientY - rect.top) / zoom - canvas.offsetTop;
        var minX = Math.min(points[0].x, points[1].x, points[2].x, points[3].x);
        var maxX = Math.max(points[0].x, points[1].x, points[2].x, points[3].x);
        var minY = Math.min(points[0].y, points[1].y, points[2].y, points[3].y);
        var maxY = Math.max(points[0].y, points[1].y, points[2].y, points[3].y);
        var offsetX = 5;
        var offsetY = 5;
        var minX = minX + offsetX;
        var maxX = maxX - offsetX;
        var minY = minY + offsetY;
        var maxY = maxY - offsetY;
        if (mouseX >= minX && mouseX <= maxX && mouseY >= minY && mouseY <= maxY) {
            return true;
        }
        return false;
    }
    function isRisingSelection(e) {
        if (points.length !== 4) {
            return false;
        }
        var rect = canvas.getBoundingClientRect();
        // adjust the mouse coordinates based on the zoom level
        var mouseX = (e.clientX - rect.left) / zoom - canvas.offsetLeft;
        var mouseY = (e.clientY - rect.top) / zoom - canvas.offsetTop;
        for (var i = 0; i < points.length; i++) {
            var dx = mouseX - points[i].x;
            var dy = mouseY - points[i].y;
            var distance = Math.sqrt(dx * dx + dy * dy);
            if (distance <= 10) {
                return true;
            }
        }
        return resizing;
    }
    var points = [];
    function mousePointer(e) {
        var rect = canvas.getBoundingClientRect();
        //fix when zoomed in
        var mouseX = (e.clientX - rect.left) / zoom - canvas.offsetLeft;
        var mouseY = (e.clientY - rect.top) / zoom - canvas.offsetTop;
        var overPoint = false;
        /*if (points.length === 0) {
            canvas.style.cursor = 'default';
        }*/
        for (var i = 0; i < points.length; i++) {
            var dx = mouseX - points[i].x;
            var dy = mouseY - points[i].y;
            var distance = Math.sqrt(dx * dx + dy * dy);
            if (distance <= 20) {
                selectedCorner = i;
                overPoint = true;
                //use nswe or nsew to determine cursor
                if (i === 0 || i === 2) {
                    canvas.style.cursor = 'nwse-resize';
                } else if (i === 1 || i === 3) {
                    canvas.style.cursor = 'nesw-resize';
                }
                return;
            }
        }
        /*if (!overPoint) {
            if (isInsideSelection(e)) {
                canvas.style.cursor = 'move';
            } else {
                canvas.style.cursor = 'default';
            }
        }*/

    }
    function selectT(e) {
        if (resizing || moving) {
            return;
        }

        var rect = canvas.getBoundingClientRect();
        //fix zoom
        var mouseX = (e.clientX - rect.left) / zoom - canvas.offsetLeft;
        var mouseY = (e.clientY - rect.top) / zoom - canvas.offsetTop;
        //create 4 points
        if (!mouseDown) {
            return;
        }
        resizing = false;
        moving = false;
        startX = startPoint.x;
        startY = startPoint.y;
        var x = (e.offsetX - rect.left) / zoom - canvas.offsetLeft;
        var y = (e.offsetY - rect.top) / zoom - canvas.offsetTop;
        var minX = Math.min(startX, x);
        var maxX = Math.max(startX, x);
        var minY = Math.min(startY, y);
        var maxY = Math.max(startY, y);
        points = [{ x: minX, y: minY }, { x: maxX, y: minY }, { x: maxX, y: maxY }, { x: minX, y: maxY }];
        if (points.length === 4) {
            drawSelection(startX, startY, x, y);
        }
    }
    function drawSelection(startX, startY, x, y) {
        startX = Math.round(startX / gridSize) * gridSize;
        startY = Math.round(startY / gridSize) * gridSize;
        x = Math.round(x / gridSize) * gridSize;
        y = Math.round(y / gridSize) * gridSize;

        //lock the corners to the grid
        redrawGrid();
        context.strokeStyle = 'black';
        context.lineWidth = 1;
        context.strokeRect(startX, startY, x - startX, y - startY);
        context.fillStyle = 'white';
        context.beginPath();
        context.arc(startX, startY, 5, 0, 2 * Math.PI);
        context.fill();
        context.stroke();
        context.beginPath();
        context.arc(x, startY, 5, 0, 2 * Math.PI);
        context.fill();
        context.stroke();
        context.beginPath();
        context.arc(x, y, 5, 0, 2 * Math.PI);
        context.fill();
        context.stroke();
        context.beginPath();
        context.arc(startX, y, 5, 0, 2 * Math.PI);
        context.fill();
        context.stroke();


    }
    function resizeSelection(e) {
        if (moving) {
            return;
        }
        // keep opposite corner anchored and move the other corners based on the mouse position
        var rect = canvas.getBoundingClientRect();
        // adjust the mouse coordinates based on the zoom level
        var mouseX = (e.clientX - rect.left) / zoom - canvas.offsetLeft;
        var mouseY = (e.clientY - rect.top) / zoom - canvas.offsetTop;
        var oppositeCorner = (selectedCorner + 2) % 4;
        drawSelection(points[oppositeCorner].x, points[oppositeCorner].y, mouseX, mouseY);
        newPoints = []
        var newWidth = points[oppositeCorner].x - mouseX;
        var newHeight = points[oppositeCorner].y - mouseY;
        newPoints[oppositeCorner] = { x: points[oppositeCorner].x, y: points[oppositeCorner].y };
        newPoints[(oppositeCorner + 1) % 4] = { x: mouseX, y: points[oppositeCorner].y };
        newPoints[(oppositeCorner + 2) % 4] = { x: mouseX, y: mouseY };
        newPoints[(oppositeCorner + 3) % 4] = { x: points[oppositeCorner].x, y: mouseY };
        points = newPoints;
    }
    var initialMouseX, initialMouseY;
    function moveSelection(e) {
        var rect = canvas.getBoundingClientRect();
        // adjust the mouse coordinates based on the zoom level
        var mouseX = (e.clientX - rect.left) / zoom - canvas.offsetLeft;
        var mouseY = (e.clientY - rect.top) / zoom - canvas.offsetTop;
        if (initialMouseX === undefined || initialMouseY === undefined) {
            initialMouseX = mouseX;
            initialMouseY = mouseY;
        }
        var dx = mouseX - initialMouseX;
        var dy = mouseY - initialMouseY;
        var newPoints = points.map((point, i) => {
            var newX = point.x + dx;
            var newY = point.y + dy;
            // snap the new position to the grid
            newX = Math.round(newX / gridSize) * gridSize;
            newY = Math.round(newY / gridSize) * gridSize;
            return { x: newX, y: newY };
        });
        initialMouseX = mouseX;
        initialMouseY = mouseY;
        redrawGrid();
        drawSelection(newPoints[0].x, newPoints[0].y, newPoints[2].x, newPoints[2].y);
        points = newPoints;

    }
    function eyedropperTool(e) {
        var rect = canvas.getBoundingClientRect();
        var x = (e.pageX - window.scrollX - rect.left) / zoom;
        var y = (e.pageY - window.scrollY - rect.top) / zoom;
        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);
        color = grid[i][j];
        if (color.includes("#")) {
            wheel.value = color;
        } else {
            wheel.value = colourNameToHex(color);
        }
        pen.checked = true;
        eraser.checked = false;
        fill.checked = false;
        line.checked = false;
        circle.checked = false;
        rect.checked = false;
        eyedropper.checked = false;
        //make activate mouse up event
        mouseDown = false;

    }
    var startPoint = null;
    var endPoint = null;
    var queue2 = [];
    function drawLine(x, y, x2, y2, rad) {
        rad2 = rad * 4;
        var dx = x2 - x;
        var dy = y2 - y;
        var len = Math.sqrt(dx * dx + dy * dy);
        var radX = rad2 * dy / len;
        var radY = rad2 * dx / len;
        drawLinePos(x - radX, y + radY, x2 - radX, y2 + radY, 0);
        drawLinePos(x + radX, y - radY, x2 + radX, y2 - radY, 0);
        //as grid size decreases, the number of intervals decreases, at 5 it should be 1, at 2 it should be .1
        var intervals = Math.max(1, Math.round(rad / 5)) / 10;
        if (rad > intervals) {
            drawLine(x, y, x2, y2, rad - intervals);
        }
        drawLinePos(x, y, x2, y2, 0);

    }

    function drawLinePos(x, y, x2, y2) {
        //use bresenhams line algorithm to draw a line between x,y and x2,y2
        var slope = (y2 - y) / (x2 - x);
        var dx = Math.abs(x2 - x);
        var dy = Math.abs(y2 - y);
        var steps = Math.max(dx, dy);
        var xInc = (x2 - x) / steps;
        var yInc = (y2 - y) / steps;
        for (var i = 0; i <= steps; i++) {
            drawPixelCoords(x + i * xInc, y + i * yInc, 0);
        }

    }
    function drawPixelCoords(x, y, penSize) {
        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);
        // Draw a circle of pixels around the point (i, j)
        for (var di = -penSize; di <= penSize; di++) {
            for (var dj = -penSize; dj <= penSize; dj++) {
                // Calculate the distance to the center point
                var dist = Math.sqrt(di * di + dj * dj);
                // If the distance is less than or equal to the penSize, color the point
                if (dist <= penSize) {
                    var ii = i + di;
                    var jj = j + dj;
                    // Check if the point is inside the grid
                    if (ii >= 0 && ii < grid.length && jj >= 0 && jj < grid[0].length) {
                        grid[ii][jj] = color;
                        context.fillStyle = color;
                        context.fillRect(ii * gridSize, jj * gridSize, gridSize, gridSize);
                    }
                }
            }
        }
    }
    function drawPixel(e, penSize) {
        lastPoint = { x: e.offsetX, y: e.offsetY };
        var rect = canvas.getBoundingClientRect();
        var x = e.pageX - window.scrollX - rect.left;
        var y = e.pageY - window.scrollY - rect.top;
        var x = (e.pageX - window.scrollX - rect.left) / zoom;
        var y = (e.pageY - window.scrollY - rect.top) / zoom;

        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);
        // Draw a circle of pixels around the point (i, j)
        for (var di = -penSize; di <= penSize; di++) {
            for (var dj = -penSize; dj <= penSize; dj++) {
                // Calculate the distance to the center point
                var dist = Math.sqrt(di * di + dj * dj);
                // If the distance is less than or equal to the penSize, color the point
                if (dist <= penSize) {
                    var ii = i + di;
                    var jj = j + dj;
                    // Check if the point is inside the grid
                    if (ii >= 0 && ii < grid.length && jj >= 0 && jj < grid[0].length) {
                        grid[ii][jj] = color;
                        context.fillStyle = color;
                        context.fillRect(ii * gridSize, jj * gridSize, gridSize, gridSize);
                    }
                }
            }
        }
    }
    //erase pixel
    function erasePixel(e, penSize) {
        var rect = canvas.getBoundingClientRect();
        var x = (e.pageX - window.scrollX - rect.left) / zoom;
        var y = (e.pageY - window.scrollY - rect.top) / zoom;

        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);

        // Draw a circle of pixels around the point (i, j)
        for (var di = -penSize; di <= penSize; di++) {
            for (var dj = -penSize; dj <= penSize; dj++) {
                // Calculate the distance to the center point
                var dist = Math.sqrt(di * di + dj * dj);
                // If the distance is less than or equal to the penSize, color the point
                if (dist <= penSize) {
                    var ii = i + di;
                    var jj = j + dj;
                    // Check if the point is inside the grid
                    if (ii >= 0 && ii < grid.length && jj >= 0 && jj < grid[0].length) {
                        var rect = canvas.getBoundingClientRect();
                        grid[ii][jj] = '';
                        context.clearRect(ii * gridSize, jj * gridSize, gridSize, gridSize);


                    }
                }
            }
        }
    }
    function drawCircle(x1, y1, x2, y2, ps) {
        var radius = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        var x = radius;
        var y = 0;
        var err = 0;
        while (x >= y) {
            drawPixelCoords(x1 + x, y1 + y, 0);
            drawPixelCoords(x1 + y, y1 + x, 0);
            drawPixelCoords(x1 - y, y1 + x, 0);
            drawPixelCoords(x1 - x, y1 + y, 0);
            drawPixelCoords(x1 - x, y1 - y, 0);
            drawPixelCoords(x1 - y, y1 - x, 0);
            drawPixelCoords(x1 + y, y1 - x, 0);
            drawPixelCoords(x1 + x, y1 - y, 0);
            if (err <= 0) {
                y += 1;
                err += 2 * y + 1;
            }
            if (err > 0) {
                x -= 1;
                err -= 2 * x + 1;
            }
        }
        if (ps > 0) {
            //draw a circle with smaller x and y
            drawCircle(x1, y1, x2 - 1, y2 - 1, ps - 1);
        }
    }
    function drawRect(x1, y1, x2, y2) {
        if (x1 > x2) {
            var temp = x1;
            x1 = x2;
            x2 = temp;
        }
        if (y1 > y2) {
            var temp = y1;
            y1 = y2;
            y2 = temp;
        }
        drawLine(x1 - (penSize * 4), y1, x2 + (penSize * 4), y1, penSize);
        drawLine(x1 - (penSize * 4), y2, x2 + (penSize * 4), y2, penSize);
        drawLine(x1, y1 - (penSize * 4), x1, y2 + (penSize * 4), penSize);
        drawLine(x2, y1 - (penSize * 4), x2, y2 + (penSize * 4), penSize);


    }
    //flood fill
    function includesCoordinate(checked, coord) {
        for (var i = 0; i < checked.length; i++) {
            if (checked[i][0] === coord[0] && checked[i][1] === coord[1]) {
                return true;
            }
        }
        return false;
    }

    function fillPixel(e) {
        var rect = canvas.getBoundingClientRect();
        var x = (e.pageX - window.scrollX - rect.left) / zoom;
        var y = (e.pageY - window.scrollY - rect.top) / zoom;
        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);
        var targetColor = grid[i][j];
        //log the time the function takes to execute in ms
        var start = performance.now();
        //oldfloodFill(i, j, targetColor, color);
        floodFill(i, j, targetColor, color);
        console.log(performance.now() - start + 'ms');
        redrawGrid();
    }

    //flood fill algorithm
    function floodFill(x, y, targetColor, replacementColor) {
        //create empty stack
        var queue = [[x, y]];
        var visited = new Set();
        //add to stack
        //while stack is not empty
        while (queue.length) {
            //remove first value from stack
            var [i, j] = queue.shift();
            //if the pixel is out of bounds, continue
            if (i < 0 || i >= gridWidth || j < 0 || j >= gridHeight) {
                continue;
            }
            if (grid[i][j] !== targetColor) {
                continue;
            }
            var coord = `${i},${j}`;
            if (visited.has(coord)) {
                continue;
            }
            grid[i][j] = replacementColor;
            redrawPixel(i, j);
            visited.add(coord);
            queue.push([i + 1, j]);
            queue.push([i - 1, j]);
            queue.push([i, j + 1]);
            queue.push([i, j - 1]);
        }
    }

    function redrawPixel(i, j) {
        context.fillStyle = grid[i][j];
        context.fillRect(i * gridSize, j * gridSize, gridSize, gridSize);
    }

    //clear button, remove all pixels, and redraw the grid
    var clear = document.getElementById('clear');
    clear.addEventListener('click', function () {
        context.clearRect(0, 0, width, height);
        for (var i = 0; i < gridWidth; i++) {
            for (var j = 0; j < gridHeight; j++) {
                grid[i][j] = '';
            }
        }

    });
    //make sure that all other radios aren't selected 
    var tools = document.querySelectorAll('input[type="radio"]');
    tools.forEach(function (tool) {
        tool.addEventListener('click', function () {
            tools.forEach(function (t) {
                if (t !== tool) {
                    t.checked = false;
                    points = [];
                    if (t === selectTool) {
                        redrawGrid();
                    }
                }
            });
        });
    });

    console.log((![] + [])[+![]])

</script>

</html>