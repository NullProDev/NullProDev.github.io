<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <div id="canvascont">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>
        <div id="tools">
            <button id="clear">Clear</button>
            <div id="toolbar">
                <!--pen, eraser and fill tool-->
                <input type="radio" id="pen" name="tool"> Pen <br>
                <input type="radio" id="eraser" name="tool"> Eraser <br>
                <input type="radio" id="fill" name="tool"> Fill <br>
                <input type="radio" id="line" name="tool"> Line <br>
                <input type="radio" id="eyedropper" name=""> Eye Dropper <br>
                <button id="export">Export</button>
            </div>
            <div class="sbs">
                <button id="undo">Undo</button>
                <button id="redo">Redo</button>
            </div>
            <div class="sbs">
                <button id="psminus">-</button>
                <p id="ps"> 1 </p>
                <button id="psplus">+</button>
            </div>
        </div>
    </div>
    <div id="container">
        <div id="color-wheel"></div>
        <input type="color" id="wheel" />
    </div>
</body>
<style>
    #canvascont {
        width: 800px;
        height: 600px;
        overflow: hidden;
    }

    input[type="radio"] {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        border: 1px solid black;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: inline-block;
        position: relative;
        cursor: pointer;
        margin: 5px 10px;
        vertical-align: middle;
    }

    input[type="radio"]:checked::before {
        content: '';
        display: block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: black;
    }

    .sbs {
        display: flex;
        flex-direction: row;
    }

    button {
        border: 0;
        background-color: white;
        padding: 15px 32px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
    }

    #app {
        display: flex;
        flex-direction: row;
    }

    canvas {
        border: 1px solid black;
        background-image: linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc 100%), linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc 100%);
        background-size: 20px 20px;
        background-position: 0 0, 10px 10px;
    }

    #container {
        margin-top: 20px;
        display: flex;
    }

    #wheel {
        height: 50px;
        width: 50px;
        margin-top: 7px;
        border: 0;

    }

    #clear {
        height: 50px;
        width: 100px;
        font-size: 20px;
        border: 0;
        background-color: black;
        color: white;
        padding: 15px 32px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
    }

    #eyedropper {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        border: 1px solid black;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: inline-block;
        position: relative;
        cursor: pointer;
        margin: 5px 10px;
        vertical-align: middle;
    }
</style>
<script>
    //export
    var exportButton = document.getElementById('export');
    exportButton.addEventListener('click', function () {
        //confirm
        var r = confirm('Are you sure you want to export?');
        if (!r) {
            return;
        }
        var dataURL = canvas.toDataURL();
        var a = document.createElement('a');
        a.href = dataURL;
        a.download = 'pixel-art.png';
        a.click();
    });
    function colourNameToHex(colour) {

        var allColors = {
            "black": "#000000", "blue": "#0000ff", "brown": "#a52a2a", "cyan": "#00ffff", "gold": "#ffd700", "gray": "#808080", "green": "#008000", "indigo": "#4b0082", "magenta": "#ff00ff", "orange": "#ffa500", "pink": "#ffc0cb", "purple": "#800080", "red": "#ff0000", "violet": "#ee82ee", "white": "#ffffff", "yellow": "#ffff00"
        };
        if (typeof allColors[colour.toLowerCase()] != 'undefined') {
            return allColors[colour.toLowerCase()];
        }
        return false;
    }
    //+- pen size
    var addPensize = document.getElementById('psplus');
    var subtractMinus = document.getElementById('psminus');
    var pen = document.getElementById('ps');
    var line = document.getElementById('line');
    addPensize.addEventListener('click', function () {
        penSize++;
        updatePenSize();
    });

    subtractMinus.addEventListener('click', function () {
        if (penSize > 0) {
            penSize--;
        }
        updatePenSize();
    });
    //undo and redo with ctrl z and ctrl shift z
    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'black', 'white'];
    let penSize = 0;
    function updatePenSize() {
        document.getElementById('ps').innerHTML = penSize + 1;
    }
    var eyedropper = document.getElementById('eyedropper');
    document.addEventListener('keydown', function (e) {
        if (e.ctrlKey && e.key === 'z') {
            undo.click();
        }
        if (e.ctrlKey && e.shiftKey && e.key === 'Z') {
            redo.click();
        }
        if (e.key === 'c') {
            clear.click();
        }
        if (e.key === 'p') {
            pen.click();
        }
        if (e.key === 'e') {
            eraser.click();
        }
        if (e.key === 'f') {
            fill.click();
        }
        if (e.key === 'l') {
            line.click();
        }
        if (e.key === '=' || e.key === '+') {
            penSize += 1;
            updatePenSize();
        }
        if (e.key === 'i') {
            eyedropper.click();
        }
        if (e.key === '-') {
            if (penSize > 0) {
                penSize -= 1;
                updatePenSize();
            }
        }
        // if key is a number
        if (e.key >= 0 && e.key <= 9) {
            color = colors[parseInt(e.key)];
            wheel.value = colourNameToHex(color);
        }
    });

    //color wheel
    var colorWheel = document.getElementById('color-wheel');
    var wheel = document.getElementById('wheel');
    for (var i = 0; i < colors.length; i++) {
        var div = document.createElement('div');
        div.style.width = '50px';
        div.style.height = '50px';
        div.style.backgroundColor = colors[i];
        div.style.display = 'inline-block';
        div.style.margin = '10px';
        div.onclick = function () {
            color = this.style.backgroundColor;
            wheel.value = colourNameToHex(color);
        };
        colorWheel.appendChild(div);
    }
    var color = 'black';
    //get input from wheel
    wheel.addEventListener('input', function () {
        color = wheel.value;
    });

    //split canvas into a grid and only allow drawing in the grid
    //mobile convert touch to mouse events
    var canvas = document.getElementById('canvas');
    canvas.addEventListener('touchstart', function (e) {
        mouseDown = true;
        startPoint = { x: e.offsetX, y: e.offsetY };
        if(line.checked){
            startingGrid = grid.map(row => [...row]);
        }
        mouseDown = true;
        if (!line.checked) {
            draw(e);
        }
    });
    canvas.addEventListener('touchmove', function (e) {
        e.preventDefault();
        if (!line.checked) {
            draw(e);
        }
        if (e.touches.length === 2) {
            var touch1 = e.touches[0];
            var touch2 = e.touches[1];
            var dx = touch1.clientX - touch2.clientX;
            var dy = touch1.clientY - touch2.clientY;
            var distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 100) {
                var rect = canvas.getBoundingClientRect();
                var x = (touch1.pageX - window.scrollX - rect.left) / zoom;
                var y = (touch1.pageY - window.scrollY - rect.top) / zoom;
                var i = Math.floor(x / gridSize);
                var j = Math.floor(y / gridSize);
                color = grid[i][j];
                wheel.value = colourNameToHex(color);
            }
        } 
        if (line.checked && startPoint) {
            endPoint = { x: e.offsetX, y: e.offsetY };
            //draw the grid to be starting grid
            grid = startingGrid.map(row => [...row]);
            //redraw only changed pixels
            redrawGrid();
            drawLine(startPoint.x, startPoint.y, endPoint.x, endPoint.y, penSize);


        }
    });
    canvas.addEventListener('touchend', function (e) {
        if (line.checked && startPoint) {
            endPoint = { x: e.offsetX, y: e.offsetY };
            drawLine(startPoint.x, startPoint.y, endPoint.x, endPoint.y, penSize);
            console.log(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
        }
        startPoint = null;
        mouseDown = false;
    });
    //convert two finger zoom to scroll 

    var context = canvas.getContext('2d');

    var width = canvas.width;
    var height = canvas.height;

    var gridSize = 10;
    var gridWidth = width / gridSize;
    var gridHeight = height / gridSize;
    var grid = [];
    var zoom = 1;
    //zoom in and out of the canvas with the mouse wheel
    canvas.addEventListener('wheel', function (e) {
        e.preventDefault();
        if (e.deltaY < 0) {
            zoom *= 1.1;
        } else {
            zoom /= 1.1;
        }
        if (zoom < .2) {
            zoom = .2;
        }
        //get pixel mouse is over
        //translate the canvas so that the mouse is always over the same pixel
        canvas.style.transformOrigin = '50% 50%';
        canvas.style.transform = 'scale(' + zoom + ')';

    });
    //pixel art
    for (var i = 0; i < gridWidth; i++) {
        grid[i] = [];
        for (var j = 0; j < gridHeight; j++) {
            // erase all
            grid[i][j] = '';


        }
    }
    //draw on grid
    var mouseDown = false;
    var isDrawing = false;
    canvas.addEventListener('mousedown', function (e) {
        startPoint = { x: e.offsetX, y: e.offsetY };
        if(line.checked){
            startingGrid = grid.map(row => [...row]);
        }
        mouseDown = true;
        if (!line.checked) {
            draw(e);
        }
    });
    canvas.addEventListener('mouseup', function (e) {
        if (line.checked && startPoint) {
            endPoint = { x: e.offsetX, y: e.offsetY };
            drawLine(startPoint.x, startPoint.y, endPoint.x, endPoint.y, penSize);
            console.log(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
        }
        startPoint = null;
        mouseDown = false;
    });
    //mouse move event
    canvas.addEventListener('mousemove', function (e) {
        if (!line.checked) {
            draw(e);
        }
        if (line.checked && startPoint) {
            endPoint = { x: e.offsetX, y: e.offsetY };
            //draw the grid to be starting grid
            grid = startingGrid.map(row => [...row]);
            //redraw only changed pixels
            redrawGrid();
            drawLine(startPoint.x, startPoint.y, endPoint.x, endPoint.y, penSize);


        }

    });

    //undo and redo
    var undo = document.getElementById('undo');
    var redo = document.getElementById('redo');
    //check if two grids are the same
    function isSameGrid(grid1, grid2) {
        for (var i = 0; i < gridWidth; i++) {
            for (var j = 0; j < gridHeight; j++) {
                if (grid1[i][j] !== grid2[i][j]) {
                    return false;
                }
            }
        }
        return true;
    }
    undo.addEventListener('click', function () {
        if (undoHistory.length > 0) {
            redoHistory.push(grid.map(row => [...row]));
            grid = undoHistory.pop();
            redrawGrid();
        }
    });
    redo.addEventListener('click', function () {
        if (redoHistory.length > 0) {
            undoHistory.push(grid.map(row => [...row]));
            grid = redoHistory.pop();
            redrawGrid();
        }
    });
    var undoHistory = [];
    var redoHistory = [];
    function pushToHistory(grid) {
        if (undoHistory.length === 0) {
            undoHistory.push(grid);
            return;
        }
        if (!isSameGrid(grid, undoHistory[undoHistory.length - 1])) {
            undoHistory.push(grid);
            redoHistory = [];
        }
    }
    function redrawGrid() {
        for (var i = 0; i < gridWidth; i++) {
            for (var j = 0; j < gridHeight; j++) {

                if (grid[i][j] === '') {
                    context.clearRect(i * gridSize, j * gridSize, gridSize, gridSize);
                } else {
                    context.fillStyle = grid[i][j];
                    context.fillRect(i * gridSize, j * gridSize, gridSize, gridSize);
                }
            }
        }
        context.strokeStyle = 'black';
    }
    //check if pen or eraser is selected
    function draw(e) {
        endPoint = { x: e.offsetX, y: e.offsetY };

        grid = grid.map(row => row.map(cell => cell.trim()));
        //add to history
        if (!mouseDown) {

            return;
        }
        if (pen.checked) {
            pushToHistory(grid.map(row => [...row]));
            drawPixel(e, penSize);
        } else if (eraser.checked) {
            pushToHistory(grid.map(row => [...row]));
            erasePixel(e, penSize);
        } else if (fill.checked) {
            pushToHistory(grid.map(row => [...row]));
            fillPixel(e);
        } else if (eyedropper.checked) {
            eyedropperTool(e);
        }
    }
    function eyedropperTool(e) {
        var rect = canvas.getBoundingClientRect();
        var x = (e.pageX - window.scrollX - rect.left) / zoom;
        var y = (e.pageY - window.scrollY - rect.top) / zoom;
        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);
        color = grid[i][j];
        wheel.value = colourNameToHex(color);
    }
    var startPoint = null;
    var endPoint = null;
    var queue2 = [];
    function drawLine(x1, y1, x2, y2, ps) {
        prevGrid = grid.map(row => [...row]);
        pushToHistory(prevGrid);
        var dx = x2 - x1;
        var dy = y2 - y1;
        var m = dy / dx;
        var dx = x2 - x1;
        var dy = y2 - y1;
        var m = dy / dx;
        if (Math.abs(m) <= 1) {
            // Slope is between -1 and 1, iterate over x values
            if (dx < 0) {
                [x1, x2] = [x2, x1];
                [y1, y2] = [y2, y1];
            }
            for (var x = x1; x <= x2; x++) {
                var y = Math.round(m * (x - x1) + y1);
                drawPixelCoords(x,y,ps)
                
            }
        } else {
            // Slope is outside -1 and 1, iterate over y values
            if (dy < 0) {
                [x1, x2] = [x2, x1];
                [y1, y2] = [y2, y1];
            }
            for (var y = y1; y <= y2; y++) {
                var x = Math.round((y - y1) / m + x1);
                drawPixelCoords(x,y,ps);
                
            }
        }

    }

    function drawPixelCoords(x,y,penSize){
        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);
        // Draw a circle of pixels around the point (i, j)
        for (var di = -penSize; di <= penSize; di++) {
            for (var dj = -penSize; dj <= penSize; dj++) {
                // Calculate the distance to the center point
                var dist = Math.sqrt(di * di + dj * dj);
                // If the distance is less than or equal to the penSize, color the point
                if (dist <= penSize) {
                    var ii = i + di;
                    var jj = j + dj;
                    // Check if the point is inside the grid
                    if (ii >= 0 && ii < grid.length && jj >= 0 && jj < grid[0].length) {
                        grid[ii][jj] = color;
                        context.fillStyle = color;
                        context.fillRect(ii * gridSize, jj * gridSize, gridSize, gridSize);
                    }
                }
            }
        }
    }
    function drawPixel(e, penSize) {
        var rect = canvas.getBoundingClientRect();
        var x = e.pageX - window.scrollX - rect.left;
        var y = e.pageY - window.scrollY - rect.top;
        var x = (e.pageX - window.scrollX - rect.left) / zoom;
        var y = (e.pageY - window.scrollY - rect.top) / zoom;

        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);
        // Draw a circle of pixels around the point (i, j)
        for (var di = -penSize; di <= penSize; di++) {
            for (var dj = -penSize; dj <= penSize; dj++) {
                // Calculate the distance to the center point
                var dist = Math.sqrt(di * di + dj * dj);
                // If the distance is less than or equal to the penSize, color the point
                if (dist <= penSize) {
                    var ii = i + di;
                    var jj = j + dj;
                    // Check if the point is inside the grid
                    if (ii >= 0 && ii < grid.length && jj >= 0 && jj < grid[0].length) {
                        grid[ii][jj] = color;
                        context.fillStyle = color;
                        context.fillRect(ii * gridSize, jj * gridSize, gridSize, gridSize);
                    }
                }
            }
        }
    }
    //erase pixel
    function erasePixel(e, penSize) {
        var rect = canvas.getBoundingClientRect();
        var x = (e.pageX - window.scrollX - rect.left) / zoom;
        var y = (e.pageY - window.scrollY - rect.top) / zoom;

        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);

        // Draw a circle of pixels around the point (i, j)
        for (var di = -penSize; di <= penSize; di++) {
            for (var dj = -penSize; dj <= penSize; dj++) {
                // Calculate the distance to the center point
                var dist = Math.sqrt(di * di + dj * dj);
                // If the distance is less than or equal to the penSize, color the point
                if (dist <= penSize) {
                    var ii = i + di;
                    var jj = j + dj;
                    // Check if the point is inside the grid
                    if (ii >= 0 && ii < grid.length && jj >= 0 && jj < grid[0].length) {
                        var rect = canvas.getBoundingClientRect();
                        grid[ii][jj] = '';
                        context.clearRect(ii * gridSize, jj * gridSize, gridSize, gridSize);


                    }
                }
            }
        }
    }
    //flood fill
    function includesCoordinate(checked, coord) {
        for (var i = 0; i < checked.length; i++) {
            if (checked[i][0] === coord[0] && checked[i][1] === coord[1]) {
                return true;
            }
        }
        return false;
    }

    function fillPixel(e) {
        var rect = canvas.getBoundingClientRect();
        var x = (e.pageX - window.scrollX - rect.left) / zoom;
        var y = (e.pageY - window.scrollY - rect.top) / zoom;
        var i = Math.floor(x / gridSize);
        var j = Math.floor(y / gridSize);
        var targetColor = grid[i][j];
        //log the time the function takes to execute in ms
        var start = performance.now();
        //oldfloodFill(i, j, targetColor, color);
        floodFill(i, j, targetColor, color);
        console.log(performance.now() - start + 'ms');
        redrawGrid();
    }

    //flood fill algorithm
    function floodFill(x, y, targetColor, replacementColor) {
        //create empty stack
        var queue = [[x, y]];
        var visited = new Set();
        //add to stack
        //while stack is not empty
        while (queue.length) {
            //remove first value from stack
            var [i, j] = queue.shift();
            //if the pixel is out of bounds, continue
            if (i < 0 || i >= gridWidth || j < 0 || j >= gridHeight) {
                continue;
            }
            if (grid[i][j] !== targetColor) {
                continue;
            }
            var coord = `${i},${j}`;
            if (visited.has(coord)) {
                continue;
            }
            grid[i][j] = replacementColor;
            redrawPixel(i, j);
            visited.add(coord);
            queue.push([i + 1, j]);
            queue.push([i - 1, j]);
            queue.push([i, j + 1]);
            queue.push([i, j - 1]);
        }
    }

    function redrawPixel(i, j) {
        context.fillStyle = grid[i][j];
        context.fillRect(i * gridSize, j * gridSize, gridSize, gridSize);
    }

    //clear button, remove all pixels, and redraw the grid
    var clear = document.getElementById('clear');
    clear.addEventListener('click', function () {
        context.clearRect(0, 0, width, height);
        for (var i = 0; i < gridWidth; i++) {
            for (var j = 0; j < gridHeight; j++) {
                grid[i][j] = '';
            }
        }

    });

    //make sure that all other tools aren't selected 
    var pen = document.getElementById('pen');
    pen.checked = true;
    pen.addEventListener('click', function () {
        pen.checked = true;
        eraser.checked = false;
        fill.checked = false;
        eyedropper.checked = false;
    });

    var eraser = document.getElementById('eraser');
    eraser.addEventListener('click', function () {
        pen.checked = false;
        eraser.checked = true;
        fill.checked = false;
        line.checked = false;
        eyedropper.checked = false;
    });

    var fill = document.getElementById('fill');
    fill.addEventListener('click', function () {
        pen.checked = false;
        eraser.checked = false;
        fill.checked = true;
        line.checked = false;
        eyedropper.checked = false;
    });

    line.addEventListener('click', function () {
        pen.checked = false;
        eraser.checked = false;
        fill.checked = false;
        line.checked = true;
        eyedropper.checked = false;
    });

    eyedropper.addEventListener('click', function () {
        pen.checked = false;
        eraser.checked = false;
        fill.checked = false;
        line.checked = false;
        eyedropper.checked = true;
    });
</script>

</html>